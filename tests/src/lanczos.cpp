#include <gtest/gtest.h>
#include "irlba/lanczos.hpp"
#include "irlba/utils.hpp"
#include "Eigen/Dense"
#include "NormalSampler.h"

TEST(Lanczos, Orthogonalize) {
    // Generated by svd(matrix(rnorm(20), 5, 4))$u
    Eigen::MatrixXd m(5, 4);
    m <<  0.1186600,  0.9038716,  0.10194199,  0.2484399218,
         -0.3090796, -0.1659502,  0.52915799, -0.3366910627,
         -0.3107643, -0.2636561, -0.35950860,  0.7248074228,
         -0.1683330,  0.1634341, -0.75523159, -0.5473305105,
          0.8749166, -0.2434161, -0.09989224, -0.0004957394;

    auto orthogonalize_vector = [](const Eigen::MatrixXd& mat, Eigen::VectorXd& vec, size_t ncols) -> void {
        Eigen::VectorXd tmp(mat.cols());
        irlba::internal::orthogonalize_vector(mat, vec, ncols, tmp);
    };

    // Generated by rnorm(5)
    Eigen::VectorXd v(5);
    v << -0.24054848, -0.04785069, -0.76491749, -0.65634291, 0.62815141;

    auto copy = v;
    orthogonalize_vector(m, copy, 4);

    // Checking that the L2 norm is not all-zero.
    double l2 = 0;
    for (auto x : copy) { l2 += x*x; }
    EXPECT_TRUE(l2 > 0.1);

    // Checking that we do have orthogonality.
    for (size_t i = 0; i < 4; ++i) {
        auto col = m.col(i);
        auto cit = col.begin();
        double sum = 0;
        for (auto x : copy) {
            sum += x * (*cit);
        }
        EXPECT_TRUE(sum < 0.0000000001);
    }

    // Checking that the specification of columns has an effect.
    auto copy2 = v;
    orthogonalize_vector(m, copy, 2);
    EXPECT_NE(copy, copy2);
}

class LanczosTester : public ::testing::TestWithParam<std::tuple<int, int, int> > {
protected:
    template<class Param>
    void assemble(Param param) {
        nr = std::get<0>(param);
        nc = std::get<1>(param);
        work = std::get<2>(param);

        A = Eigen::MatrixXd(nr, nc);
        W = Eigen::MatrixXd(nr, work);
        V = Eigen::MatrixXd(nc, work);
        B = Eigen::MatrixXd(work, work);
        B.setZero();

        NormalSampler norm(42);
        for (size_t i = 0; i < nc; ++i) {
            for (size_t j = 0; j < nr; ++j) {
                A(j, i) = norm();
            }
        }

        for (size_t i = 0; i < nc; ++i) {
            V(i) = norm();
        }
        V.col(0) /= V.col(0).norm();
    }

    size_t nr, nc, work;
    Eigen::MatrixXd A, W, V, B;
};

TEST_P(LanczosTester, Basic) {
    assemble(GetParam());

    irlba::Options opt;
    std::mt19937_64 eng(50);
    irlba::internal::LanczosWorkspace<Eigen::VectorXd, Eigen::MatrixXd> init(A);
    irlba::internal::run_lanczos_bidiagonalization(A, W, V, B, eng, init, 0, opt);

    // Check that vectors in W are self-orthogonal.
    Eigen::MatrixXd Wcheck = W.adjoint() * W;
    for (size_t i = 0; i < work; ++i) {
        for (size_t j = 0; j < work; ++j) {
            if (i==j) {
                EXPECT_FLOAT_EQ(Wcheck(i, j), 1);
            } else {
                EXPECT_TRUE(std::abs(Wcheck(i, j)) < 0.00000000001);
            }
        }
    }

    // Check that vectors in V are self-orthogonal.
    Eigen::MatrixXd Vcheck = V.adjoint() * V;
    for (size_t i = 0; i < work; ++i) {
        for (size_t j = 0; j < work; ++j) {
            if (i==j) {
                EXPECT_FLOAT_EQ(Vcheck(i, j), 1);
            } else {
                EXPECT_TRUE(std::abs(Vcheck(i, j)) < 0.00000000001);
            }
        }
    }
}

TEST_P(LanczosTester, Restart) {
    assemble(GetParam());

    irlba::Options opt;
    std::mt19937_64 eng(50);
    irlba::internal::LanczosWorkspace<Eigen::VectorXd, Eigen::MatrixXd> init(A);

    // Computing the bidiagonlization for the first half of the working dimensions.
    int mid = work / 2;
    Eigen::MatrixXd subW = W.leftCols(mid); 
    Eigen::MatrixXd subV = V.leftCols(mid); 
    Eigen::MatrixXd subB = B.topLeftCorner(mid,mid); 
    irlba::internal::run_lanczos_bidiagonalization(A, subW, subV, subB, eng, init, 0, opt);

    // Restarting the bidiagonlization for the second half.
    Eigen::MatrixXd copyW(nr, work);
    copyW.leftCols(mid) = subW;
    Eigen::MatrixXd copyV(nc, work);
    copyV.leftCols(mid) = subV;
    Eigen::MatrixXd copyB(work, work);
    copyB.setZero();
    copyB.topLeftCorner(mid,mid) = subB;
    copyV.col(mid) = init.F / init.F.norm();
    irlba::internal::run_lanczos_bidiagonalization(A, copyW, copyV, copyB, eng, init, mid, opt); //restarting from start = mid.

    // Numerically equivalent to a full compuation... except for B, where the
    // restart loses one of the superdiagonal elements (which is normally 
    // filled in by the residual error in the IRLBA loop, see Equation 3.6).
    std::mt19937_64 eng2(50);
    irlba::internal::LanczosWorkspace<Eigen::VectorXd, Eigen::MatrixXd> init2(A);
    irlba::internal::run_lanczos_bidiagonalization(A, W, V, B, eng, init2, 0, opt);

    for (size_t i = 0; i < copyW.cols(); ++i) {
        for (size_t j = 0; j < copyW.rows(); ++j) {
            EXPECT_FLOAT_EQ(copyW(j, i), W(j, i));
        }
    }

    for (size_t i = 0; i < copyV.cols(); ++i) {
        for (size_t j = 0; j < copyV.rows(); ++j) {
            EXPECT_FLOAT_EQ(copyV(j, i), V(j, i));
        }
    }
}

INSTANTIATE_TEST_SUITE_P(
    LanczosTests,
    LanczosTester,
    ::testing::Combine(
        ::testing::Values(10, 20, 30), // number of rows
        ::testing::Values(10, 20, 30), // number of columns
        ::testing::Values(3, 5, 7) // workspace
    )
);
